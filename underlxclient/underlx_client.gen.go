// Package underlxclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package underlxclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiPairScopes = "apiPair.Scopes"
)

// Defines values for DisturbanceCategories.
const (
	COMMUNITYREPORTED DisturbanceCategories = "COMMUNITY_REPORTED"
	N3RDPARTYFAULT    DisturbanceCategories = "3RD_PARTY_FAULT"
	PASSENGERINCIDENT DisturbanceCategories = "PASSENGER_INCIDENT"
	POWEROUTAGE       DisturbanceCategories = "POWER_OUTAGE"
	SIGNALFAILURE     DisturbanceCategories = "SIGNAL_FAILURE"
	STATIONANOMALY    DisturbanceCategories = "STATION_ANOMALY"
	TRAINFAILURE      DisturbanceCategories = "TRAIN_FAILURE"
)

// Defines values for FeedbackType.
const (
	S2lsIncorrectDetection FeedbackType = "s2ls-incorrect-detection"
)

// Defines values for GatewayProtocol.
const (
	Mqtt GatewayProtocol = "mqtt"
)

// Defines values for MapType.
const (
	Html     MapType = "html"
	WorldMap MapType = "world-map"
)

// Defines values for POIType.
const (
	Airport           POIType = "airport"
	Bank              POIType = "bank"
	Business          POIType = "business"
	Casino            POIType = "casino"
	Cemetery          POIType = "cemetery"
	Church            POIType = "church"
	Dinning           POIType = "dinning"
	Embassy           POIType = "embassy"
	FireStation       POIType = "fire-station"
	Government        POIType = "government"
	HealthCenter      POIType = "health-center"
	Hospital          POIType = "hospital"
	Hotel             POIType = "hotel"
	Institute         POIType = "institute"
	Library           POIType = "library"
	Market            POIType = "market"
	Monument          POIType = "monument"
	Museum            POIType = "museum"
	Organization      POIType = "organization"
	Park              POIType = "park"
	Police            POIType = "police"
	PostOffice        POIType = "post-office"
	PublicService     POIType = "public-service"
	PublicSpace       POIType = "public-space"
	School            POIType = "school"
	ShoppingCenter    POIType = "shopping-center"
	ShowRoom          POIType = "show-room"
	Sports            POIType = "sports"
	Theater           POIType = "theater"
	TransportationHub POIType = "transportation-hub"
	University        POIType = "university"
	Viewpoint         POIType = "viewpoint"
	Zoo               POIType = "zoo"
)

// Defines values for StationExitType.
const (
	Escalator StationExitType = "escalator"
	Lift      StationExitType = "lift"
	Ramp      StationExitType = "ramp"
	Stairs    StationExitType = "stairs"
)

// Defines values for StationTag.
const (
	ABaby              StationTag = "a_baby"
	AStore             StationTag = "a_store"
	AWc                StationTag = "a_wc"
	AWifi              StationTag = "a_wifi"
	CAirport           StationTag = "c_airport"
	CBike              StationTag = "c_bike"
	CBoat              StationTag = "c_boat"
	CBus               StationTag = "c_bus"
	CParking           StationTag = "c_parking"
	CTaxi              StationTag = "c_taxi"
	CTrain             StationTag = "c_train"
	MEscalatorPlatform StationTag = "m_escalator_platform"
	MEscalatorSurface  StationTag = "m_escalator_surface"
	MLiftPlatform      StationTag = "m_lift_platform"
	MLiftSurface       StationTag = "m_lift_surface"
	MPlatform          StationTag = "m_platform"
	MStepfree          StationTag = "m_stepfree"
	SClient            StationTag = "s_client"
	SInfo              StationTag = "s_info"
	SLostfound         StationTag = "s_lostfound"
	SNavegante         StationTag = "s_navegante"
	STicket1           StationTag = "s_ticket1"
	STicket2           StationTag = "s_ticket2"
	STicket3           StationTag = "s_ticket3"
	SUrgentPass        StationTag = "s_urgent_pass"
)

// Defines values for StationUseType.
const (
	GONETHROUGH  StationUseType = "GONE_THROUGH"
	INTERCHANGE  StationUseType = "INTERCHANGE"
	NETWORKENTRY StationUseType = "NETWORK_ENTRY"
	NETWORKEXIT  StationUseType = "NETWORK_EXIT"
	VISIT        StationUseType = "VISIT"
)

// Defines values for ListDisturbancesParamsFilter.
const (
	ListDisturbancesParamsFilterAll     ListDisturbancesParamsFilter = "all"
	ListDisturbancesParamsFilterOngoing ListDisturbancesParamsFilter = "ongoing"
)

// Defines values for ListLineConditionsParamsFilter.
const (
	ListLineConditionsParamsFilterAll    ListLineConditionsParamsFilter = "all"
	ListLineConditionsParamsFilterLatest ListLineConditionsParamsFilter = "latest"
)

// Defines values for ListLineConditionsForLineParamsFilter.
const (
	All    ListLineConditionsForLineParamsFilter = "all"
	Latest ListLineConditionsForLineParamsFilter = "latest"
)

// Defines values for GetStatsParamsType.
const (
	GetStatsParamsTypeOfficial   GetStatsParamsType = "official"
	GetStatsParamsTypeUnofficial GetStatsParamsType = "unofficial"
)

// Defines values for GetStatsForNetworkParamsType.
const (
	GetStatsForNetworkParamsTypeOfficial   GetStatsForNetworkParamsType = "official"
	GetStatsForNetworkParamsTypeUnofficial GetStatsForNetworkParamsType = "unofficial"
)

// Announcement defines model for Announcement.
type Announcement struct {
	Body     *string `json:"body,omitempty"`
	ImageURL *string `json:"imageURL,omitempty"`

	// Network ID of the network this announcement pertains to
	Network *string `json:"network,omitempty"`

	// Source ID of the source of this information
	Source *string    `json:"source,omitempty"`
	Time   *time.Time `json:"time,omitempty"`
	Title  *string    `json:"title,omitempty"`
	Url    *string    `json:"url,omitempty"`
}

// Connection defines model for Connection.
type Connection struct {
	// From ID of the station this connection originates from
	From *string `json:"from,omitempty"`

	// To ID of the station this connection ends at
	To *string `json:"to,omitempty"`

	// TypS Typical seconds. The average time it takes for a vehicle to go through this connection
	TypS *int `json:"typS,omitempty"`

	// TypStopS Typical stop seconds. The average time vehicles are stopping by `from` when going in the direction of `to`
	TypStopS *int `json:"typStopS,omitempty"`

	// TypWaitS Typical waiting seconds. The average time users are waiting for a vehicle at `from` when going in the direction of `to`
	TypWaitS *int `json:"typWaitS,omitempty"`

	// WorldLength The length of this connection in meters
	WorldLength *int `json:"worldLength,omitempty"`
}

// Dataset defines model for Dataset.
type Dataset struct {
	// Authors List of authors of this dataset
	Authors *[]string `json:"authors,omitempty"`

	// Network ID of the network covered by this dataset
	Network *string `json:"network,omitempty"`

	// Version Version of the dataset. Usually the date of the last modification, but this is not guaranteed to be the case forever.
	Version *string `json:"version,omitempty"`
}

// Disturbance A disturbance is a service disruption or degradation events signalled by one or more line status indicative of bad service.
type Disturbance struct {
	// Categories Categories automatically assigned by UnderLX
	Categories *[]DisturbanceCategories `json:"categories,omitempty"`

	// Description Disturbance for the description according to the sources. Usually corresponds to the first status of the disturbance
	Description *string `json:"description,omitempty"`

	// EndTime Disturbance end time. Invalid if the disturbance is still ongoing
	EndTime *time.Time `json:"endTime,omitempty"`

	// Ended Whether the disturbance has ended
	Ended *bool `json:"ended,omitempty"`

	// Id Unique disturbance ID in the UnderLX system
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Line ID of the line affected by this disturbance
	Line *string `json:"line,omitempty"`

	// Network ID of the network affected by this disturbance
	Network *string `json:"network,omitempty"`

	// Notes Notes manually added by the UnderLX team. May contain simple HTML markup, including image tags.
	Notes *string `json:"notes,omitempty"`

	// OEndTime Official end time. Invalid if the disturbance is not official or if it is still ongoing
	OEndTime *time.Time `json:"oEndTime,omitempty"`

	// OEnded Whether the disturbance has ended, according to official sources. False if the disturbance is still ongoing
	OEnded *bool `json:"oEnded,omitempty"`

	// OStartTime Official start time. Invalid if the disturbance is not official
	OStartTime *time.Time `json:"oStartTime,omitempty"`

	// Official Whether this disturbance was confirmed by official sources
	Official *bool `json:"official,omitempty"`

	// StartTime Disturbance start time. Always a valid date-time
	StartTime *time.Time `json:"startTime,omitempty"`

	// Statuses Line statuses
	Statuses *[]LineStatus `json:"statuses,omitempty"`
}

// DisturbanceCategories defines model for Disturbance.Categories.
type DisturbanceCategories string

// Feedback defines model for Feedback.
type Feedback struct {
	// Contents Arbitrary feedback data whose semantics depend on `type`
	Contents *string `json:"contents,omitempty"`

	// Id Feedback UUID as generated by the client
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Time Time at which feedback was provided
	Time *time.Time `json:"time,omitempty"`

	// Type The type of feedback
	Type *FeedbackType `json:"type,omitempty"`
}

// FeedbackType The type of feedback
type FeedbackType string

// Gateway Gateways are UnderLX's form of real-time communication between server and clients.
// They are used to support communication paradigms that are poorly supported by conventional HTTP, such as publish-subscribe or unreliable connections (as in UDP).
type Gateway struct {
	Protocol GatewayProtocol `json:"protocol"`
}

// GatewayProtocol defines model for Gateway.Protocol.
type GatewayProtocol string

// Line defines model for Line.
type Line struct {
	// Color Color associated with this line, in hexadecimal RRGGBB format.
	Color *string `json:"color,omitempty"`

	// ExternalID ID of this line in 3rd-party systems, such as the transit operator's system
	ExternalID *string `json:"externalID,omitempty"`

	// Id Unique line ID in the UnderLX system
	Id *string `json:"id,omitempty"`

	// MainLocale Key of the name to use in the `names` map, when no specific translation is available for the current locale
	MainLocale *string `json:"mainLocale,omitempty"`

	// Name Main human-friendly name of the line
	Name *string `json:"name,omitempty"`

	// Names Map of language codes to names providing name translations for each locale. If a translation is not available for the relevant locale, the one specified by `mainLocale` should be used.
	Names *map[string]string `json:"names,omitempty"`

	// Network ID of the network this line belongs to
	Network *string `json:"network,omitempty"`

	// Order Value used for sorting this line next to other lines of the same network, when displayed to users
	Order *int `json:"order,omitempty"`

	// Schedule Schedules defining the opening time of this line
	Schedule *[]Schedule `json:"schedule,omitempty"`

	// Stations IDs of stations that are part of this line, in sequential order
	Stations *[]string `json:"stations,omitempty"`

	// TypCars Typical number of cars for vehicles performing service in this line
	TypCars *int `json:"typCars,omitempty"`

	// WorldPaths Paths of the line in the real world. Some lines have multiple paths because of e.g. each direction taking a slightly different route.
	WorldPaths *[]struct {
		// Id ID of the path
		Id *string `json:"id,omitempty"`

		// Path Latitude-longitude pairs defining the path.
		Path *[][]float32 `json:"path,omitempty"`
	} `json:"worldPaths,omitempty"`
}

// LineCondition defines model for LineCondition.
type LineCondition struct {
	// Id Unique line condition ID in the UnderLX system
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Line ID of the line this condition applies to
	Line *string `json:"line,omitempty"`

	// Source Internal ID of the condition source in the UnderLX system
	Source *string `json:"source,omitempty"`

	// Time Time at which this condition was assumed
	Time *time.Time `json:"time,omitempty"`

	// TrainCars Supposed number of cars for trains performing passenger service in the line. If zero, there's no information or there is no passenger service on the line
	TrainCars *int `json:"trainCars,omitempty"`

	// TrainFrequency Target time interval between trains performing passenger service in the line
	TrainFrequency *string `json:"trainFrequency,omitempty"`
}

// LineStatus defines model for LineStatus.
type LineStatus struct {
	// Downtime Whether this status represents a disruption in the passenger service
	Downtime *bool `json:"downtime,omitempty"`

	// Id Unique line status ID in the UnderLX system
	Id *openapi_types.UUID `json:"id,omitempty"`

	// MsgType Status type as automatically identified from `status`. Can be used to facilitate automated translation of statuses by the client.
	MsgType *string `json:"msgType,omitempty"`

	// OfficialSource Whether the `source` is considered official
	OfficialSource *bool `json:"officialSource,omitempty"`

	// Source Internal ID of the status source in the UnderLX system
	Source *string `json:"source,omitempty"`

	// Status Line status as produced/captured
	Status *string `json:"status,omitempty"`

	// Time Time at which the line assumed this status (or at which UnderLX received this status for the line)
	Time *time.Time `json:"time,omitempty"`
}

// Lobby defines model for Lobby.
type Lobby struct {
	// Exits Station entrances that lead to this lobby
	Exits *[]StationExit `json:"exits,omitempty"`

	// Id Unique lobby ID in the UnderLX system
	Id *string `json:"id,omitempty"`

	// Name Human-friendly lobby name
	Name *string `json:"name,omitempty"`

	// Network ID of the network this lobby belongs to
	Network *string `json:"network,omitempty"`

	// Schedule Schedules defining the opening time of this lobby
	Schedule *[]Schedule `json:"schedule,omitempty"`

	// Station ID of the station this lobby belongs to
	Station *string `json:"station,omitempty"`
}

// Localizable defines model for Localizable.
type Localizable struct {
	// MainLocale Key of the name to use in the `names` map, when no specific translation is available for the current locale
	MainLocale *string `json:"mainLocale,omitempty"`

	// Names Map of language codes to names providing name translations for each locale. If a translation is not available for the relevant locale, the one specified by `mainLocale` should be used.
	Names *map[string]string `json:"names,omitempty"`
}

// Map Maps are used to indicate clients which human-friendly transit maps exist, how to obtain and how to render them.
// Do not confuse maps with datasets or networks. Maps are not explicitly associated to either of those, but dataset versioning indirectly controls map updates, in the sense that the client must invalidate the map cache when updating datasets.
type Map struct {
	Type MapType `json:"type"`
}

// MapType defines model for Map.Type.
type MapType string

// Meta defines model for Meta.
type Meta struct {
	// MinAndroidClient Minimum build version of the UnderLX Android client allowed to use this endpoint. If the build number is below this value, the client must refrain from using this endpoint, and tell the user to update the client.
	MinAndroidClient *int `json:"minAndroidClient,omitempty"`

	// Motd The endpoint's "Message of the day". This is a localized string meant to be displayed to the user, if possible.
	Motd *struct {
		// Html Map of language codes to strings, providing translations for each locale. Strings may contain simple HTML markup, possibly including image tags.
		// If a translation is not available for the relevant locale, the one specified by `mainLocale` should be used.
		Html *map[string]string `json:"html,omitempty"`

		// MainLocale Key of the `html` to use, when a translation is not available for the relevant locale.
		MainLocale *string `json:"mainLocale,omitempty"`

		// Priority How prominently the MOTD should be displayed to the user. Lower values signify higher priority and prominence.
		Priority *int `json:"priority,omitempty"`
	} `json:"motd,omitempty"`

	// Supported True if this API endpoint is still maintained and not deprecated. If false, clients must refrain from using this endpoint, and update their systems to use a supported endpoint, and/or inform the end user to update their client software, and/or announce service deprecation.
	Supported *bool `json:"supported,omitempty"`

	// Up True if this API endpoint is operating normally. If false, clients must refrain from using this endpoint, and inform the user of the unavailability of online services.
	Up *bool `json:"up,omitempty"`
}

// Network defines model for Network.
type Network struct {
	// Duration DEPRECATED - use schedules. Typical opening period duration of the network
	Duration *string `json:"duration,omitempty"`

	// Holidays List of holidays observed by this network, as days of the year (January 1st: 1; December 31st: 365/366).
	// This information is needed to correctly operate with schedules.
	Holidays *[]int `json:"holidays,omitempty"`

	// Id Unique network ID in the UnderLX system
	Id *string `json:"id,omitempty"`

	// Lines IDs of lines pertaining to this network
	Lines *[]string `json:"lines,omitempty"`

	// MainLocale Key of the name to use in the `names` map, when no specific translation is available for the current locale
	MainLocale *string `json:"mainLocale,omitempty"`

	// Name Main human-friendly name of the transit network
	Name *string `json:"name,omitempty"`

	// Names Map of language codes to names providing name translations for each locale. If a translation is not available for the relevant locale, the one specified by `mainLocale` should be used.
	Names *map[string]string `json:"names,omitempty"`

	// NewsURL DEPRECATED - use announcements instead
	NewsURL *string `json:"newsURL,omitempty"`

	// OpenTime DEPRECATED - use schedules. Typical opening time of the network
	OpenTime *string `json:"openTime,omitempty"`

	// Schedule Schedules defining the opening time of this network
	Schedule *[]Schedule `json:"schedule,omitempty"`

	// Stations IDs of stations pertaining to this network
	Stations *[]string `json:"stations,omitempty"`

	// Timezone Timezone of this network, used when operating with schedules
	Timezone *string `json:"timezone,omitempty"`

	// TypCars Typical number of cars for vehicles performing service in this network
	TypCars *int `json:"typCars,omitempty"`
}

// POI defines model for POI.
type POI struct {
	// Id Unique point of Interest ID in the UnderLX system
	Id *openapi_types.UUID `json:"id,omitempty"`

	// MainLocale Key of the name to use in the `names` map, when no specific translation is available for the current locale
	MainLocale *string `json:"mainLocale,omitempty"`

	// Names Map of language codes to names providing name translations for each locale. If a translation is not available for the relevant locale, the one specified by `mainLocale` should be used.
	Names *map[string]string `json:"names,omitempty"`

	// Type Type/category of point of interest
	Type *POIType `json:"type,omitempty"`

	// WebURL URL of 3rd-party web page associated with this point of interest
	WebURL *string `json:"webURL,omitempty"`

	// WorldCoord Latitude-longitude pair describing the real world position of the point of interest
	WorldCoord *[]float32 `json:"worldCoord,omitempty"`
}

// POIType Type/category of point of interest
type POIType string

// PairConnection defines model for PairConnection.
type PairConnection struct {
	// CreationTime Time of creation of this connection
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// Extra Extra service-specific information about the connection
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Service ID of the external service in the UnderLX system
	Service *string `json:"service,omitempty"`

	// ServiceName Human-friendly name of the external service
	ServiceName *string `json:"serviceName,omitempty"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	// Day Day of week (0-6: Sunday-Saturday) or day of year (January 1st: 1; December 31st: 365/366) this schedule applies to.
	// - If `holiday` is false, this schedule applies to the day of the week specified by `day`;
	// - If `holiday` is true and `day` is zero, this schedule applies to holidays, as defined in the holidays list of the relevant network;
	// - If `holiday` is true and `day` is not zero, this is a one-off schedule for a specific day of the year, and `day` should be interpreted as the day of the year. If we are past that day in the current year, this should be interpreted as the Nth day of the next year.
	Day *int `json:"day,omitempty"`

	// Duration Duration of the opening period for this day, in HH`h`mm`m`SS`s` format. May extend past the midnight of this day
	Duration *string `json:"duration,omitempty"`

	// Holiday Whether this schedule applies to holidays, or is an exception. See `day` for more information.
	Holiday *bool `json:"holiday,omitempty"`

	// Open Whether the lobby/line/network will be open on this day
	Open *bool `json:"open,omitempty"`

	// OpenTime Start of the opening period for this day, in HH`:`mm`:`SS format. The timezone is that of the relevant transit network
	OpenTime *string `json:"openTime,omitempty"`
}

// Station defines model for Station.
type Station struct {
	// AltNames Alternative names that users may use when referring to this station
	AltNames *[]string `json:"altNames,omitempty"`

	// ConnURLs Maps connection types (bike, boat, bus, park, train) to maps, that in turn, map locales to relative URLs of HTML files, which contain connection information for this station.
	// URLs are relative to the API endpoint. The HTML markup is simple, possibly including image tags
	ConnURLs *map[string]map[string]map[string]interface{} `json:"connURLs,omitempty"`

	// Features DEPRECATED - use `tags` and `lowTags`
	Features *struct {
		Airport *bool `json:"airport,omitempty"`
		Boat    *bool `json:"boat,omitempty"`
		Bus     *bool `json:"bus,omitempty"`
		Lift    *bool `json:"lift,omitempty"`
		Train   *bool `json:"train,omitempty"`
	} `json:"features,omitempty"`

	// Id Unique station ID in the UnderLX system
	Id *string `json:"id,omitempty"`

	// Lines IDs of lines serving this station
	Lines *[]string `json:"lines,omitempty"`

	// Lobbies IDs of the lobbies of this station
	Lobbies *[]string `json:"lobbies,omitempty"`

	// LowTags List of lower-priority tags. The complete list of tags, without duplicates, can be obtained by simply appending `lowTags` to `tags`
	LowTags *[]StationTag `json:"lowTags,omitempty"`

	// Name Human-friendly station name
	Name *string `json:"name,omitempty"`

	// Network ID of the network this station belongs to
	Network *string `json:"network,omitempty"`

	// Pois IDs of the POIs associated with this station
	Pois *[]openapi_types.UUID `json:"pois,omitempty"`

	// Tags List of tags that describe the station and its features, including connections to other transportation services, amenities and accessibilities
	Tags *[]StationTag `json:"tags,omitempty"`

	// TriviaURLs Maps locales to relative URLs of HTML files, containing trivia for this station.
	// URLs are relative to the API endpoint. The HTML markup is simple, possibly including image tags
	TriviaURLs *map[string]string `json:"triviaURLs,omitempty"`

	// WiFiAPs Wi-Fi Acess Points present at this station. Used by S2LS, the Segvault Subway Location System.
	WiFiAPs *[]struct {
		// Bssid BSSID of the access point
		Bssid *string `json:"bssid,omitempty"`

		// Line DEPRECATED
		Line *string `json:"line,omitempty"`
	} `json:"wiFiAPs,omitempty"`
}

// StationExit defines model for StationExit.
type StationExit struct {
	// Id ID of the station exit in the UnderLX system
	Id *int `json:"id,omitempty"`

	// Streets Names of nearby streets and places
	Streets *[]string `json:"streets,omitempty"`

	// Type The type of exit
	Type *StationExitType `json:"type,omitempty"`

	// WorldCoord Latitude-longitude pair describing the real world position of the exit
	WorldCoord *[]float32 `json:"worldCoord,omitempty"`
}

// StationExitType The type of exit
type StationExitType string

// StationTag defines model for StationTag.
type StationTag string

// StationUse defines model for StationUse.
type StationUse struct {
	// EntryTime Date-time at which the user entered the station
	EntryTime *time.Time `json:"entryTime,omitempty"`

	// LeaveTime Date-time at which the user left the station
	LeaveTime *time.Time `json:"leaveTime,omitempty"`

	// Manual Whether this use is part of a user-made edit of a trip
	Manual *bool `json:"manual,omitempty"`

	// SourceLine ID of the line the line change originated from. Only valid if `type` is INTERCHANGE
	SourceLine *string `json:"sourceLine,omitempty"`

	// Station ID of the station the user used
	Station *string `json:"station,omitempty"`

	// TargetLine ID of the target line for the line change. Only valid if `type` is INTERCHANGE
	TargetLine *string `json:"targetLine,omitempty"`

	// Type The type of station use
	Type *StationUseType `json:"type,omitempty"`
}

// StationUseType The type of station use
type StationUseType string

// Stats defines model for Stats.
type Stats struct {
	// CurOnInTransit Approximate number of UnderLX users currently online and in transit. This number is always relative to the present moment, independently of the request parameters
	CurOnInTransit *int `json:"curOnInTransit,omitempty"`

	// LastDisturbance Date-time of the end of last disturbance
	LastDisturbance *time.Time `json:"lastDisturbance,omitempty"`

	// LineStats Map containing statistics for each line, indexed by line ID
	LineStats *map[string]struct {
		// Availability Fraction of time this line operated without issues in the relevant time frame
		Availability *float32 `json:"availability,omitempty"`

		// AvgDistDuration Average disturbance duration in the relevant time frame, in HH`h`mm`m`SS`s` format
		AvgDistDuration *string `json:"avgDistDuration,omitempty"`
	} `json:"lineStats,omitempty"`
}

// Transfer defines model for Transfer.
type Transfer struct {
	// From ID of the line this transfer originates from
	From *string `json:"from,omitempty"`

	// Station ID of the station where this transfer takes place
	Station *string `json:"station,omitempty"`

	// To ID of the line this transfer ends at
	To *string `json:"to,omitempty"`

	// TypS Typical seconds. The average time it takes for a user to go through this transfer
	TypS *int `json:"typS,omitempty"`
}

// Trip defines model for Trip.
type Trip struct {
	// EditTime Date-time at which the trip was edited. Invalid if `edited` is false
	EditTime *time.Time `json:"editTime,omitempty"`

	// Edited Whether the trip was edited
	Edited *bool `json:"edited,omitempty"`

	// EndTime Date-time at which the trip ended
	EndTime *time.Time `json:"endTime,omitempty"`

	// Id Trip UUID as generated by the client
	Id *openapi_types.UUID `json:"id,omitempty"`

	// StartTime Date-time at which the trip started
	StartTime *time.Time `json:"startTime,omitempty"`

	// SubmitTime Date-time at which the trip was submitted
	SubmitTime *time.Time `json:"submitTime,omitempty"`

	// UserConfirmed Whether the trip data was confirmed by the user
	UserConfirmed *bool `json:"userConfirmed,omitempty"`

	// Uses Station uses defining the path the user took
	Uses *[]StationUse `json:"uses,omitempty"`
}

// ListDisturbancesParams defines parameters for ListDisturbances.
type ListDisturbancesParams struct {
	// Omitduplicatestatus Whether duplicate line status should be omitted. Duplicate line status are present mainly on earlier disturbances. Should always be true.
	Omitduplicatestatus *bool `form:"omitduplicatestatus,omitempty" json:"omitduplicatestatus,omitempty"`

	// Start Limit returned disturbances to those after this date-time. Incompatible with `filter=ongoing`
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Limit returned disturbances to those before this date-time. Incompatible with `filter=ongoing`
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Filter If `ongoing`, will limit returned disturbances to ongoing ones. Incompatible with `start` and `end`
	Filter *ListDisturbancesParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListDisturbancesParamsFilter defines parameters for ListDisturbances.
type ListDisturbancesParamsFilter string

// GetDisturbanceParams defines parameters for GetDisturbance.
type GetDisturbanceParams struct {
	// Omitduplicatestatus Whether duplicate line status should be omitted. Duplicate line status are present mainly on earlier disturbances. Should always be true.
	Omitduplicatestatus *bool `form:"omitduplicatestatus,omitempty" json:"omitduplicatestatus,omitempty"`
}

// ListLineConditionsParams defines parameters for ListLineConditions.
type ListLineConditionsParams struct {
	// Filter If `latest`, will limit returned conditions to current ones.
	Filter *ListLineConditionsParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListLineConditionsParamsFilter defines parameters for ListLineConditions.
type ListLineConditionsParamsFilter string

// ListLineConditionsForLineParams defines parameters for ListLineConditionsForLine.
type ListLineConditionsForLineParams struct {
	// Filter If `latest`, will limit returned conditions to the current one.
	Filter *ListLineConditionsForLineParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListLineConditionsForLineParamsFilter defines parameters for ListLineConditionsForLine.
type ListLineConditionsForLineParamsFilter string

// CreatePairJSONBody defines parameters for CreatePair.
type CreatePairJSONBody struct {
	// AndroidID Client device ID. This is used to prevent Sybil attacks.
	AndroidID *string `json:"androidID,omitempty"`

	// Nonce Client-generated 36 characters long random string. The use of a v4 UUID is recommended. This is used to prevent replay attacks.
	Nonce *openapi_types.UUID `json:"nonce,omitempty"`

	// Signature Base64-encoded SHA256 ECDSA signature of the concatenation of `nonce` with `timestamp` and `androidID`. The private key used to generate the signature is undisclosed. This is used to prevent unauthorized creation of API credentials
	Signature *string `json:"signature,omitempty"`

	// Timestamp Client-generated request timestamp, in RFC3339 format. This is used to confirm that the clock of the client is sufficiently synchronized
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// CreatePairConnectionJSONBody defines parameters for CreatePairConnection.
type CreatePairConnectionJSONBody struct {
	// Code User-provided code for association with a service
	Code *string `json:"code,omitempty"`

	// DeviceName Human-friendly name of the client device (brand, model)
	DeviceName *string `json:"deviceName,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Start Start of the range for which to compute statistics. Defaults to the present moment minus 7 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End of the range for which to compute statistics. Defaults to the present moment
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Type Whether to consider unofficial disturbances in the computations. Defaults to official only.
	Type *GetStatsParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetStatsParamsType defines parameters for GetStats.
type GetStatsParamsType string

// GetStatsForNetworkParams defines parameters for GetStatsForNetwork.
type GetStatsForNetworkParams struct {
	// Start Start of the range for which to compute statistics. Defaults to the present moment minus 7 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End of the range for which to compute statistics. Defaults to the present moment
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Type Whether to consider unofficial disturbances in the computations. Defaults to official only.
	Type *GetStatsForNetworkParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetStatsForNetworkParamsType defines parameters for GetStatsForNetwork.
type GetStatsForNetworkParamsType string

// SubmitFeedbackJSONRequestBody defines body for SubmitFeedback for application/json ContentType.
type SubmitFeedbackJSONRequestBody = Feedback

// CreatePairJSONRequestBody defines body for CreatePair for application/json ContentType.
type CreatePairJSONRequestBody CreatePairJSONBody

// CreatePairConnectionJSONRequestBody defines body for CreatePairConnection for application/json ContentType.
type CreatePairConnectionJSONRequestBody CreatePairConnectionJSONBody

// SubmitTripJSONRequestBody defines body for SubmitTrip for application/json ContentType.
type SubmitTripJSONRequestBody = Trip

// EditMyTripJSONRequestBody defines body for EditMyTrip for application/json ContentType.
type EditMyTripJSONRequestBody = Trip

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAnnouncements request
	ListAnnouncements(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAnnouncementsOfSource request
	ListAnnouncementsOfSource(ctx context.Context, sourceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckPair request
	CheckPair(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConnections request
	ListConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnection request
	GetConnection(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatasets request
	ListDatasets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataset request
	GetDataset(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDisturbances request
	ListDisturbances(ctx context.Context, params *ListDisturbancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportDisturbanceWithBody request with any body
	ReportDisturbanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDisturbance request
	GetDisturbance(ctx context.Context, id string, params *GetDisturbanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitFeedbackWithBody request with any body
	SubmitFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitFeedback(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGateways request
	ListGateways(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLines request
	ListLines(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLineConditions request
	ListLineConditions(ctx context.Context, params *ListLineConditionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineCondition request
	GetLineCondition(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLine request
	GetLine(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLineConditionsForLine request
	ListLineConditionsForLine(ctx context.Context, lineID string, params *ListLineConditionsForLineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLobbies request
	ListLobbies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLobby request
	GetLobby(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMaps request
	ListMaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeta request
	GetMeta(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackers request
	GetBackers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadBackers request
	HeadBackers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNetworks request
	ListNetworks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetwork request
	GetNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePairWithBody request with any body
	CreatePairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePair(ctx context.Context, body CreatePairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPairConnections request
	ListPairConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePairConnectionWithBody request with any body
	CreatePairConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePairConnection(ctx context.Context, body CreatePairConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPOIs request
	ListPOIs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPOI request
	GetPOI(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStations request
	ListStations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStation request
	GetStation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsForNetwork request
	GetStatsForNetwork(ctx context.Context, networkID string, params *GetStatsForNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransfers request
	ListTransfers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransfer request
	GetTransfer(ctx context.Context, stationID string, fromID string, toid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMyTrips request
	ListMyTrips(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitTripWithBody request with any body
	SubmitTripWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitTrip(ctx context.Context, body SubmitTripJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMyTripWithBody request with any body
	EditMyTripWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMyTrip(ctx context.Context, body EditMyTripJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMyTrip request
	GetMyTrip(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAnnouncements(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAnnouncementsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAnnouncementsOfSource(ctx context.Context, sourceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAnnouncementsOfSourceRequest(c.Server, sourceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckPair(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckPairRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnection(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionRequest(c.Server, from, to)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatasets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatasetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataset(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatasetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDisturbances(ctx context.Context, params *ListDisturbancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDisturbancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportDisturbanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportDisturbanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDisturbance(ctx context.Context, id string, params *GetDisturbanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDisturbanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitFeedbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitFeedback(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitFeedbackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGateways(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGatewaysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLines(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLineConditions(ctx context.Context, params *ListLineConditionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLineConditionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineCondition(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineConditionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLine(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLineConditionsForLine(ctx context.Context, lineID string, params *ListLineConditionsForLineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLineConditionsForLineRequest(c.Server, lineID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLobbies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLobbiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLobby(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLobbyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMapsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeta(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadBackers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadBackersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetworks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePairRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePair(ctx context.Context, body CreatePairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePairRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPairConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPairConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePairConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePairConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePairConnection(ctx context.Context, body CreatePairConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePairConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPOIs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPOIsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPOI(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPOIRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatsForNetwork(ctx context.Context, networkID string, params *GetStatsForNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsForNetworkRequest(c.Server, networkID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransfers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransfersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransfer(ctx context.Context, stationID string, fromID string, toid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransferRequest(c.Server, stationID, fromID, toid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMyTrips(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMyTripsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitTripWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitTripRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitTrip(ctx context.Context, body SubmitTripJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitTripRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMyTripWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMyTripRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMyTrip(ctx context.Context, body EditMyTripJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMyTripRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMyTrip(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMyTripRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAnnouncementsRequest generates requests for ListAnnouncements
func NewListAnnouncementsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/announcements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAnnouncementsOfSourceRequest generates requests for ListAnnouncementsOfSource
func NewListAnnouncementsOfSourceRequest(server string, sourceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceID", runtime.ParamLocationPath, sourceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/announcements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckPairRequest generates requests for CheckPair
func NewCheckPairRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authtest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConnectionsRequest generates requests for ListConnections
func NewListConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionRequest generates requests for GetConnection
func NewGetConnectionRequest(server string, from string, to string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatasetsRequest generates requests for ListDatasets
func NewListDatasetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatasetRequest generates requests for GetDataset
func NewGetDatasetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDisturbancesRequest generates requests for ListDisturbances
func NewListDisturbancesRequest(server string, params *ListDisturbancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/disturbances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Omitduplicatestatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "omitduplicatestatus", runtime.ParamLocationQuery, *params.Omitduplicatestatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportDisturbanceRequestWithBody generates requests for ReportDisturbance with any type of body
func NewReportDisturbanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/disturbances/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDisturbanceRequest generates requests for GetDisturbance
func NewGetDisturbanceRequest(server string, id string, params *GetDisturbanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/disturbances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Omitduplicatestatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "omitduplicatestatus", runtime.ParamLocationQuery, *params.Omitduplicatestatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitFeedbackRequest calls the generic SubmitFeedback builder with application/json body
func NewSubmitFeedbackRequest(server string, body SubmitFeedbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitFeedbackRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitFeedbackRequestWithBody generates requests for SubmitFeedback with any type of body
func NewSubmitFeedbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feedback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGatewaysRequest generates requests for ListGateways
func NewListGatewaysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gateways")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLinesRequest generates requests for ListLines
func NewListLinesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLineConditionsRequest generates requests for ListLineConditions
func NewListLineConditionsRequest(server string, params *ListLineConditionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines/conditions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineConditionRequest generates requests for GetLineCondition
func NewGetLineConditionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines/conditions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineRequest generates requests for GetLine
func NewGetLineRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLineConditionsForLineRequest generates requests for ListLineConditionsForLine
func NewListLineConditionsForLineRequest(server string, lineID string, params *ListLineConditionsForLineParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lineID", runtime.ParamLocationPath, lineID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLobbiesRequest generates requests for ListLobbies
func NewListLobbiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lobbies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLobbyRequest generates requests for GetLobby
func NewGetLobbyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lobbies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMapsRequest generates requests for ListMaps
func NewListMapsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetaRequest generates requests for GetMeta
func NewGetMetaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackersRequest generates requests for GetBackers
func NewGetBackersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta/backers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadBackersRequest generates requests for HeadBackers
func NewHeadBackersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta/backers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNetworksRequest generates requests for ListNetworks
func NewListNetworksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkRequest generates requests for GetNetwork
func NewGetNetworkRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePairRequest calls the generic CreatePair builder with application/json body
func NewCreatePairRequest(server string, body CreatePairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePairRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePairRequestWithBody generates requests for CreatePair with any type of body
func NewCreatePairRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPairConnectionsRequest generates requests for ListPairConnections
func NewListPairConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePairConnectionRequest calls the generic CreatePairConnection builder with application/json body
func NewCreatePairConnectionRequest(server string, body CreatePairConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePairConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePairConnectionRequestWithBody generates requests for CreatePairConnection with any type of body
func NewCreatePairConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPOIsRequest generates requests for ListPOIs
func NewListPOIsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pois")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPOIRequest generates requests for GetPOI
func NewGetPOIRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pois/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStationsRequest generates requests for ListStations
func NewListStationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStationRequest generates requests for GetStation
func NewGetStationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, params *GetStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsForNetworkRequest generates requests for GetStatsForNetwork
func NewGetStatsForNetworkRequest(server string, networkID string, params *GetStatsForNetworkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkID", runtime.ParamLocationPath, networkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTransfersRequest generates requests for ListTransfers
func NewListTransfersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransferRequest generates requests for GetTransfer
func NewGetTransferRequest(server string, stationID string, fromID string, toid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationID", runtime.ParamLocationPath, stationID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fromID", runtime.ParamLocationPath, fromID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "toID", runtime.ParamLocationPath, toid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMyTripsRequest generates requests for ListMyTrips
func NewListMyTripsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitTripRequest calls the generic SubmitTrip builder with application/json body
func NewSubmitTripRequest(server string, body SubmitTripJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitTripRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitTripRequestWithBody generates requests for SubmitTrip with any type of body
func NewSubmitTripRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditMyTripRequest calls the generic EditMyTrip builder with application/json body
func NewEditMyTripRequest(server string, body EditMyTripJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMyTripRequestWithBody(server, "application/json", bodyReader)
}

// NewEditMyTripRequestWithBody generates requests for EditMyTrip with any type of body
func NewEditMyTripRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMyTripRequest generates requests for GetMyTrip
func NewGetMyTripRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAnnouncementsWithResponse request
	ListAnnouncementsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAnnouncementsResponse, error)

	// ListAnnouncementsOfSourceWithResponse request
	ListAnnouncementsOfSourceWithResponse(ctx context.Context, sourceID string, reqEditors ...RequestEditorFn) (*ListAnnouncementsOfSourceResponse, error)

	// CheckPairWithResponse request
	CheckPairWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckPairResponse, error)

	// ListConnectionsWithResponse request
	ListConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectionsResponse, error)

	// GetConnectionWithResponse request
	GetConnectionWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetConnectionResponse, error)

	// ListDatasetsWithResponse request
	ListDatasetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDatasetsResponse, error)

	// GetDatasetWithResponse request
	GetDatasetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatasetResponse, error)

	// ListDisturbancesWithResponse request
	ListDisturbancesWithResponse(ctx context.Context, params *ListDisturbancesParams, reqEditors ...RequestEditorFn) (*ListDisturbancesResponse, error)

	// ReportDisturbanceWithBodyWithResponse request with any body
	ReportDisturbanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportDisturbanceResponse, error)

	// GetDisturbanceWithResponse request
	GetDisturbanceWithResponse(ctx context.Context, id string, params *GetDisturbanceParams, reqEditors ...RequestEditorFn) (*GetDisturbanceResponse, error)

	// SubmitFeedbackWithBodyWithResponse request with any body
	SubmitFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error)

	SubmitFeedbackWithResponse(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error)

	// ListGatewaysWithResponse request
	ListGatewaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGatewaysResponse, error)

	// ListLinesWithResponse request
	ListLinesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLinesResponse, error)

	// ListLineConditionsWithResponse request
	ListLineConditionsWithResponse(ctx context.Context, params *ListLineConditionsParams, reqEditors ...RequestEditorFn) (*ListLineConditionsResponse, error)

	// GetLineConditionWithResponse request
	GetLineConditionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLineConditionResponse, error)

	// GetLineWithResponse request
	GetLineWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLineResponse, error)

	// ListLineConditionsForLineWithResponse request
	ListLineConditionsForLineWithResponse(ctx context.Context, lineID string, params *ListLineConditionsForLineParams, reqEditors ...RequestEditorFn) (*ListLineConditionsForLineResponse, error)

	// ListLobbiesWithResponse request
	ListLobbiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLobbiesResponse, error)

	// GetLobbyWithResponse request
	GetLobbyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLobbyResponse, error)

	// ListMapsWithResponse request
	ListMapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMapsResponse, error)

	// GetMetaWithResponse request
	GetMetaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetaResponse, error)

	// GetBackersWithResponse request
	GetBackersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBackersResponse, error)

	// HeadBackersWithResponse request
	HeadBackersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HeadBackersResponse, error)

	// ListNetworksWithResponse request
	ListNetworksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error)

	// GetNetworkWithResponse request
	GetNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworkResponse, error)

	// CreatePairWithBodyWithResponse request with any body
	CreatePairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePairResponse, error)

	CreatePairWithResponse(ctx context.Context, body CreatePairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePairResponse, error)

	// ListPairConnectionsWithResponse request
	ListPairConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPairConnectionsResponse, error)

	// CreatePairConnectionWithBodyWithResponse request with any body
	CreatePairConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePairConnectionResponse, error)

	CreatePairConnectionWithResponse(ctx context.Context, body CreatePairConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePairConnectionResponse, error)

	// ListPOIsWithResponse request
	ListPOIsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPOIsResponse, error)

	// GetPOIWithResponse request
	GetPOIWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPOIResponse, error)

	// ListStationsWithResponse request
	ListStationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListStationsResponse, error)

	// GetStationWithResponse request
	GetStationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStationResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetStatsForNetworkWithResponse request
	GetStatsForNetworkWithResponse(ctx context.Context, networkID string, params *GetStatsForNetworkParams, reqEditors ...RequestEditorFn) (*GetStatsForNetworkResponse, error)

	// ListTransfersWithResponse request
	ListTransfersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTransfersResponse, error)

	// GetTransferWithResponse request
	GetTransferWithResponse(ctx context.Context, stationID string, fromID string, toid string, reqEditors ...RequestEditorFn) (*GetTransferResponse, error)

	// ListMyTripsWithResponse request
	ListMyTripsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMyTripsResponse, error)

	// SubmitTripWithBodyWithResponse request with any body
	SubmitTripWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitTripResponse, error)

	SubmitTripWithResponse(ctx context.Context, body SubmitTripJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitTripResponse, error)

	// EditMyTripWithBodyWithResponse request with any body
	EditMyTripWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMyTripResponse, error)

	EditMyTripWithResponse(ctx context.Context, body EditMyTripJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMyTripResponse, error)

	// GetMyTripWithResponse request
	GetMyTripWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMyTripResponse, error)
}

type ListAnnouncementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Announcement
}

// Status returns HTTPResponse.Status
func (r ListAnnouncementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAnnouncementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAnnouncementsOfSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Announcement
}

// Status returns HTTPResponse.Status
func (r ListAnnouncementsOfSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAnnouncementsOfSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Echoing of the API pair key
		Key *string `json:"key,omitempty"`

		// Result Should be `ok`
		Result *string `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Connection
}

// Status returns HTTPResponse.Status
func (r ListConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Connection
}

// Status returns HTTPResponse.Status
func (r GetConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatasetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Dataset
}

// Status returns HTTPResponse.Status
func (r ListDatasetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatasetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatasetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dataset
}

// Status returns HTTPResponse.Status
func (r GetDatasetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatasetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDisturbancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Disturbance
}

// Status returns HTTPResponse.Status
func (r ListDisturbancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDisturbancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportDisturbanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportDisturbanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportDisturbanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDisturbanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Disturbance
}

// Status returns HTTPResponse.Status
func (r GetDisturbanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDisturbanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Feedback
}

// Status returns HTTPResponse.Status
func (r SubmitFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGatewaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Gateway
}

// Status returns HTTPResponse.Status
func (r ListGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Line
}

// Status returns HTTPResponse.Status
func (r ListLinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLineConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LineCondition
}

// Status returns HTTPResponse.Status
func (r ListLineConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLineConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LineCondition
}

// Status returns HTTPResponse.Status
func (r GetLineConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Line
}

// Status returns HTTPResponse.Status
func (r GetLineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLineConditionsForLineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LineCondition
}

// Status returns HTTPResponse.Status
func (r ListLineConditionsForLineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLineConditionsForLineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLobbiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Lobby
}

// Status returns HTTPResponse.Status
func (r ListLobbiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLobbiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLobbyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lobby
}

// Status returns HTTPResponse.Status
func (r GetLobbyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLobbyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Map
}

// Status returns HTTPResponse.Status
func (r ListMapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meta
}

// Status returns HTTPResponse.Status
func (r GetMetaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBackersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadBackersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadBackersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadBackersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNetworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Network
}

// Status returns HTTPResponse.Status
func (r ListNetworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Network
}

// Status returns HTTPResponse.Status
func (r GetNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Activation Date-time after which this pair is valid and can be used to access the API
		Activation *time.Time `json:"activation,omitempty"`

		// Key API access key. Should be provided as the username in exchanges that require one, like HTTP Basic Auth or the MQTT CONNECT packet
		Key *string `json:"key,omitempty"`

		// Secret API access secret. Should be provided as the password in exchanges that require one, like HTTP Basic Auth or the MQTT CONNECT packet
		Secret *string `json:"secret,omitempty"`

		// Type Pair type
		Type *string `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPairConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PairConnection
}

// Status returns HTTPResponse.Status
func (r ListPairConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPairConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePairConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Should be `connected`
		Result *string `json:"result,omitempty"`

		// ServiceName Human-friendly name of the service the user just connected with
		ServiceName *string `json:"serviceName,omitempty"`
	}
	JSON404 *struct {
		Result *string `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePairConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePairConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPOIsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]POI
}

// Status returns HTTPResponse.Status
func (r ListPOIsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPOIsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPOIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *POI
}

// Status returns HTTPResponse.Status
func (r GetPOIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPOIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Station
}

// Status returns HTTPResponse.Status
func (r ListStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Station
}

// Status returns HTTPResponse.Status
func (r GetStationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Stats
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsForNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stats
}

// Status returns HTTPResponse.Status
func (r GetStatsForNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsForNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransfersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Transfer
}

// Status returns HTTPResponse.Status
func (r ListTransfersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransfersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transfer
}

// Status returns HTTPResponse.Status
func (r GetTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMyTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Trip
}

// Status returns HTTPResponse.Status
func (r ListMyTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMyTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitTripResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Trip
}

// Status returns HTTPResponse.Status
func (r SubmitTripResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitTripResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMyTripResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Trip
}

// Status returns HTTPResponse.Status
func (r EditMyTripResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMyTripResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMyTripResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Trip
}

// Status returns HTTPResponse.Status
func (r GetMyTripResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMyTripResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAnnouncementsWithResponse request returning *ListAnnouncementsResponse
func (c *ClientWithResponses) ListAnnouncementsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAnnouncementsResponse, error) {
	rsp, err := c.ListAnnouncements(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAnnouncementsResponse(rsp)
}

// ListAnnouncementsOfSourceWithResponse request returning *ListAnnouncementsOfSourceResponse
func (c *ClientWithResponses) ListAnnouncementsOfSourceWithResponse(ctx context.Context, sourceID string, reqEditors ...RequestEditorFn) (*ListAnnouncementsOfSourceResponse, error) {
	rsp, err := c.ListAnnouncementsOfSource(ctx, sourceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAnnouncementsOfSourceResponse(rsp)
}

// CheckPairWithResponse request returning *CheckPairResponse
func (c *ClientWithResponses) CheckPairWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckPairResponse, error) {
	rsp, err := c.CheckPair(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckPairResponse(rsp)
}

// ListConnectionsWithResponse request returning *ListConnectionsResponse
func (c *ClientWithResponses) ListConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectionsResponse, error) {
	rsp, err := c.ListConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectionsResponse(rsp)
}

// GetConnectionWithResponse request returning *GetConnectionResponse
func (c *ClientWithResponses) GetConnectionWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetConnectionResponse, error) {
	rsp, err := c.GetConnection(ctx, from, to, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionResponse(rsp)
}

// ListDatasetsWithResponse request returning *ListDatasetsResponse
func (c *ClientWithResponses) ListDatasetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDatasetsResponse, error) {
	rsp, err := c.ListDatasets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatasetsResponse(rsp)
}

// GetDatasetWithResponse request returning *GetDatasetResponse
func (c *ClientWithResponses) GetDatasetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatasetResponse, error) {
	rsp, err := c.GetDataset(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatasetResponse(rsp)
}

// ListDisturbancesWithResponse request returning *ListDisturbancesResponse
func (c *ClientWithResponses) ListDisturbancesWithResponse(ctx context.Context, params *ListDisturbancesParams, reqEditors ...RequestEditorFn) (*ListDisturbancesResponse, error) {
	rsp, err := c.ListDisturbances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDisturbancesResponse(rsp)
}

// ReportDisturbanceWithBodyWithResponse request with arbitrary body returning *ReportDisturbanceResponse
func (c *ClientWithResponses) ReportDisturbanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportDisturbanceResponse, error) {
	rsp, err := c.ReportDisturbanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportDisturbanceResponse(rsp)
}

// GetDisturbanceWithResponse request returning *GetDisturbanceResponse
func (c *ClientWithResponses) GetDisturbanceWithResponse(ctx context.Context, id string, params *GetDisturbanceParams, reqEditors ...RequestEditorFn) (*GetDisturbanceResponse, error) {
	rsp, err := c.GetDisturbance(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDisturbanceResponse(rsp)
}

// SubmitFeedbackWithBodyWithResponse request with arbitrary body returning *SubmitFeedbackResponse
func (c *ClientWithResponses) SubmitFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error) {
	rsp, err := c.SubmitFeedbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFeedbackResponse(rsp)
}

func (c *ClientWithResponses) SubmitFeedbackWithResponse(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error) {
	rsp, err := c.SubmitFeedback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFeedbackResponse(rsp)
}

// ListGatewaysWithResponse request returning *ListGatewaysResponse
func (c *ClientWithResponses) ListGatewaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGatewaysResponse, error) {
	rsp, err := c.ListGateways(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGatewaysResponse(rsp)
}

// ListLinesWithResponse request returning *ListLinesResponse
func (c *ClientWithResponses) ListLinesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLinesResponse, error) {
	rsp, err := c.ListLines(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinesResponse(rsp)
}

// ListLineConditionsWithResponse request returning *ListLineConditionsResponse
func (c *ClientWithResponses) ListLineConditionsWithResponse(ctx context.Context, params *ListLineConditionsParams, reqEditors ...RequestEditorFn) (*ListLineConditionsResponse, error) {
	rsp, err := c.ListLineConditions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLineConditionsResponse(rsp)
}

// GetLineConditionWithResponse request returning *GetLineConditionResponse
func (c *ClientWithResponses) GetLineConditionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLineConditionResponse, error) {
	rsp, err := c.GetLineCondition(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineConditionResponse(rsp)
}

// GetLineWithResponse request returning *GetLineResponse
func (c *ClientWithResponses) GetLineWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLineResponse, error) {
	rsp, err := c.GetLine(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineResponse(rsp)
}

// ListLineConditionsForLineWithResponse request returning *ListLineConditionsForLineResponse
func (c *ClientWithResponses) ListLineConditionsForLineWithResponse(ctx context.Context, lineID string, params *ListLineConditionsForLineParams, reqEditors ...RequestEditorFn) (*ListLineConditionsForLineResponse, error) {
	rsp, err := c.ListLineConditionsForLine(ctx, lineID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLineConditionsForLineResponse(rsp)
}

// ListLobbiesWithResponse request returning *ListLobbiesResponse
func (c *ClientWithResponses) ListLobbiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLobbiesResponse, error) {
	rsp, err := c.ListLobbies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLobbiesResponse(rsp)
}

// GetLobbyWithResponse request returning *GetLobbyResponse
func (c *ClientWithResponses) GetLobbyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLobbyResponse, error) {
	rsp, err := c.GetLobby(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLobbyResponse(rsp)
}

// ListMapsWithResponse request returning *ListMapsResponse
func (c *ClientWithResponses) ListMapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMapsResponse, error) {
	rsp, err := c.ListMaps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMapsResponse(rsp)
}

// GetMetaWithResponse request returning *GetMetaResponse
func (c *ClientWithResponses) GetMetaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetaResponse, error) {
	rsp, err := c.GetMeta(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaResponse(rsp)
}

// GetBackersWithResponse request returning *GetBackersResponse
func (c *ClientWithResponses) GetBackersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBackersResponse, error) {
	rsp, err := c.GetBackers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackersResponse(rsp)
}

// HeadBackersWithResponse request returning *HeadBackersResponse
func (c *ClientWithResponses) HeadBackersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HeadBackersResponse, error) {
	rsp, err := c.HeadBackers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadBackersResponse(rsp)
}

// ListNetworksWithResponse request returning *ListNetworksResponse
func (c *ClientWithResponses) ListNetworksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error) {
	rsp, err := c.ListNetworks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworksResponse(rsp)
}

// GetNetworkWithResponse request returning *GetNetworkResponse
func (c *ClientWithResponses) GetNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworkResponse, error) {
	rsp, err := c.GetNetwork(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkResponse(rsp)
}

// CreatePairWithBodyWithResponse request with arbitrary body returning *CreatePairResponse
func (c *ClientWithResponses) CreatePairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePairResponse, error) {
	rsp, err := c.CreatePairWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePairResponse(rsp)
}

func (c *ClientWithResponses) CreatePairWithResponse(ctx context.Context, body CreatePairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePairResponse, error) {
	rsp, err := c.CreatePair(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePairResponse(rsp)
}

// ListPairConnectionsWithResponse request returning *ListPairConnectionsResponse
func (c *ClientWithResponses) ListPairConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPairConnectionsResponse, error) {
	rsp, err := c.ListPairConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPairConnectionsResponse(rsp)
}

// CreatePairConnectionWithBodyWithResponse request with arbitrary body returning *CreatePairConnectionResponse
func (c *ClientWithResponses) CreatePairConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePairConnectionResponse, error) {
	rsp, err := c.CreatePairConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePairConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreatePairConnectionWithResponse(ctx context.Context, body CreatePairConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePairConnectionResponse, error) {
	rsp, err := c.CreatePairConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePairConnectionResponse(rsp)
}

// ListPOIsWithResponse request returning *ListPOIsResponse
func (c *ClientWithResponses) ListPOIsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPOIsResponse, error) {
	rsp, err := c.ListPOIs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPOIsResponse(rsp)
}

// GetPOIWithResponse request returning *GetPOIResponse
func (c *ClientWithResponses) GetPOIWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPOIResponse, error) {
	rsp, err := c.GetPOI(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPOIResponse(rsp)
}

// ListStationsWithResponse request returning *ListStationsResponse
func (c *ClientWithResponses) ListStationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListStationsResponse, error) {
	rsp, err := c.ListStations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStationsResponse(rsp)
}

// GetStationWithResponse request returning *GetStationResponse
func (c *ClientWithResponses) GetStationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStationResponse, error) {
	rsp, err := c.GetStation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStationResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetStatsForNetworkWithResponse request returning *GetStatsForNetworkResponse
func (c *ClientWithResponses) GetStatsForNetworkWithResponse(ctx context.Context, networkID string, params *GetStatsForNetworkParams, reqEditors ...RequestEditorFn) (*GetStatsForNetworkResponse, error) {
	rsp, err := c.GetStatsForNetwork(ctx, networkID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsForNetworkResponse(rsp)
}

// ListTransfersWithResponse request returning *ListTransfersResponse
func (c *ClientWithResponses) ListTransfersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTransfersResponse, error) {
	rsp, err := c.ListTransfers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransfersResponse(rsp)
}

// GetTransferWithResponse request returning *GetTransferResponse
func (c *ClientWithResponses) GetTransferWithResponse(ctx context.Context, stationID string, fromID string, toid string, reqEditors ...RequestEditorFn) (*GetTransferResponse, error) {
	rsp, err := c.GetTransfer(ctx, stationID, fromID, toid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransferResponse(rsp)
}

// ListMyTripsWithResponse request returning *ListMyTripsResponse
func (c *ClientWithResponses) ListMyTripsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMyTripsResponse, error) {
	rsp, err := c.ListMyTrips(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMyTripsResponse(rsp)
}

// SubmitTripWithBodyWithResponse request with arbitrary body returning *SubmitTripResponse
func (c *ClientWithResponses) SubmitTripWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitTripResponse, error) {
	rsp, err := c.SubmitTripWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitTripResponse(rsp)
}

func (c *ClientWithResponses) SubmitTripWithResponse(ctx context.Context, body SubmitTripJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitTripResponse, error) {
	rsp, err := c.SubmitTrip(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitTripResponse(rsp)
}

// EditMyTripWithBodyWithResponse request with arbitrary body returning *EditMyTripResponse
func (c *ClientWithResponses) EditMyTripWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMyTripResponse, error) {
	rsp, err := c.EditMyTripWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMyTripResponse(rsp)
}

func (c *ClientWithResponses) EditMyTripWithResponse(ctx context.Context, body EditMyTripJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMyTripResponse, error) {
	rsp, err := c.EditMyTrip(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMyTripResponse(rsp)
}

// GetMyTripWithResponse request returning *GetMyTripResponse
func (c *ClientWithResponses) GetMyTripWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMyTripResponse, error) {
	rsp, err := c.GetMyTrip(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMyTripResponse(rsp)
}

// ParseListAnnouncementsResponse parses an HTTP response from a ListAnnouncementsWithResponse call
func ParseListAnnouncementsResponse(rsp *http.Response) (*ListAnnouncementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAnnouncementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Announcement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListAnnouncementsOfSourceResponse parses an HTTP response from a ListAnnouncementsOfSourceWithResponse call
func ParseListAnnouncementsOfSourceResponse(rsp *http.Response) (*ListAnnouncementsOfSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAnnouncementsOfSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Announcement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseCheckPairResponse parses an HTTP response from a CheckPairWithResponse call
func ParseCheckPairResponse(rsp *http.Response) (*CheckPairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Echoing of the API pair key
			Key *string `json:"key,omitempty"`

			// Result Should be `ok`
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListConnectionsResponse parses an HTTP response from a ListConnectionsWithResponse call
func ParseListConnectionsResponse(rsp *http.Response) (*ListConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Connection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetConnectionResponse parses an HTTP response from a GetConnectionWithResponse call
func ParseGetConnectionResponse(rsp *http.Response) (*GetConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Connection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListDatasetsResponse parses an HTTP response from a ListDatasetsWithResponse call
func ParseListDatasetsResponse(rsp *http.Response) (*ListDatasetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatasetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetDatasetResponse parses an HTTP response from a GetDatasetWithResponse call
func ParseGetDatasetResponse(rsp *http.Response) (*GetDatasetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatasetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListDisturbancesResponse parses an HTTP response from a ListDisturbancesWithResponse call
func ParseListDisturbancesResponse(rsp *http.Response) (*ListDisturbancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDisturbancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Disturbance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseReportDisturbanceResponse parses an HTTP response from a ReportDisturbanceWithResponse call
func ParseReportDisturbanceResponse(rsp *http.Response) (*ReportDisturbanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportDisturbanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDisturbanceResponse parses an HTTP response from a GetDisturbanceWithResponse call
func ParseGetDisturbanceResponse(rsp *http.Response) (*GetDisturbanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDisturbanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Disturbance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseSubmitFeedbackResponse parses an HTTP response from a SubmitFeedbackWithResponse call
func ParseSubmitFeedbackResponse(rsp *http.Response) (*SubmitFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Feedback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.StatusCode == 201:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListGatewaysResponse parses an HTTP response from a ListGatewaysWithResponse call
func ParseListGatewaysResponse(rsp *http.Response) (*ListGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Gateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListLinesResponse parses an HTTP response from a ListLinesWithResponse call
func ParseListLinesResponse(rsp *http.Response) (*ListLinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Line
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListLineConditionsResponse parses an HTTP response from a ListLineConditionsWithResponse call
func ParseListLineConditionsResponse(rsp *http.Response) (*ListLineConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLineConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LineCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetLineConditionResponse parses an HTTP response from a GetLineConditionWithResponse call
func ParseGetLineConditionResponse(rsp *http.Response) (*GetLineConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetLineResponse parses an HTTP response from a GetLineWithResponse call
func ParseGetLineResponse(rsp *http.Response) (*GetLineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Line
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListLineConditionsForLineResponse parses an HTTP response from a ListLineConditionsForLineWithResponse call
func ParseListLineConditionsForLineResponse(rsp *http.Response) (*ListLineConditionsForLineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLineConditionsForLineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LineCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListLobbiesResponse parses an HTTP response from a ListLobbiesWithResponse call
func ParseListLobbiesResponse(rsp *http.Response) (*ListLobbiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLobbiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Lobby
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetLobbyResponse parses an HTTP response from a GetLobbyWithResponse call
func ParseGetLobbyResponse(rsp *http.Response) (*GetLobbyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLobbyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lobby
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListMapsResponse parses an HTTP response from a ListMapsWithResponse call
func ParseListMapsResponse(rsp *http.Response) (*ListMapsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetMetaResponse parses an HTTP response from a GetMetaWithResponse call
func ParseGetMetaResponse(rsp *http.Response) (*GetMetaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetBackersResponse parses an HTTP response from a GetBackersWithResponse call
func ParseGetBackersResponse(rsp *http.Response) (*GetBackersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadBackersResponse parses an HTTP response from a HeadBackersWithResponse call
func ParseHeadBackersResponse(rsp *http.Response) (*HeadBackersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadBackersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListNetworksResponse parses an HTTP response from a ListNetworksWithResponse call
func ParseListNetworksResponse(rsp *http.Response) (*ListNetworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Network
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetNetworkResponse parses an HTTP response from a GetNetworkWithResponse call
func ParseGetNetworkResponse(rsp *http.Response) (*GetNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Network
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseCreatePairResponse parses an HTTP response from a CreatePairWithResponse call
func ParseCreatePairResponse(rsp *http.Response) (*CreatePairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Activation Date-time after which this pair is valid and can be used to access the API
			Activation *time.Time `json:"activation,omitempty"`

			// Key API access key. Should be provided as the username in exchanges that require one, like HTTP Basic Auth or the MQTT CONNECT packet
			Key *string `json:"key,omitempty"`

			// Secret API access secret. Should be provided as the password in exchanges that require one, like HTTP Basic Auth or the MQTT CONNECT packet
			Secret *string `json:"secret,omitempty"`

			// Type Pair type
			Type *string `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListPairConnectionsResponse parses an HTTP response from a ListPairConnectionsWithResponse call
func ParseListPairConnectionsResponse(rsp *http.Response) (*ListPairConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPairConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PairConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseCreatePairConnectionResponse parses an HTTP response from a CreatePairConnectionWithResponse call
func ParseCreatePairConnectionResponse(rsp *http.Response) (*CreatePairConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePairConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Should be `connected`
			Result *string `json:"result,omitempty"`

			// ServiceName Human-friendly name of the service the user just connected with
			ServiceName *string `json:"serviceName,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListPOIsResponse parses an HTTP response from a ListPOIsWithResponse call
func ParseListPOIsResponse(rsp *http.Response) (*ListPOIsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPOIsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []POI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetPOIResponse parses an HTTP response from a GetPOIWithResponse call
func ParseGetPOIResponse(rsp *http.Response) (*GetPOIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPOIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest POI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListStationsResponse parses an HTTP response from a ListStationsWithResponse call
func ParseListStationsResponse(rsp *http.Response) (*ListStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Station
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetStationResponse parses an HTTP response from a GetStationWithResponse call
func ParseGetStationResponse(rsp *http.Response) (*GetStationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Station
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetStatsForNetworkResponse parses an HTTP response from a GetStatsForNetworkWithResponse call
func ParseGetStatsForNetworkResponse(rsp *http.Response) (*GetStatsForNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsForNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListTransfersResponse parses an HTTP response from a ListTransfersWithResponse call
func ParseListTransfersResponse(rsp *http.Response) (*ListTransfersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransfersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetTransferResponse parses an HTTP response from a GetTransferWithResponse call
func ParseGetTransferResponse(rsp *http.Response) (*GetTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseListMyTripsResponse parses an HTTP response from a ListMyTripsWithResponse call
func ParseListMyTripsResponse(rsp *http.Response) (*ListMyTripsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMyTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Trip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseSubmitTripResponse parses an HTTP response from a SubmitTripWithResponse call
func ParseSubmitTripResponse(rsp *http.Response) (*SubmitTripResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitTripResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Trip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.StatusCode == 201:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseEditMyTripResponse parses an HTTP response from a EditMyTripWithResponse call
func ParseEditMyTripResponse(rsp *http.Response) (*EditMyTripResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMyTripResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Trip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetMyTripResponse parses an HTTP response from a GetMyTripWithResponse call
func ParseGetMyTripResponse(rsp *http.Response) (*GetMyTripResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMyTripResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Trip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}
